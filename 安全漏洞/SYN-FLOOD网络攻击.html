<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h1>拒绝服务攻击介绍</h1>
    <p> 
        使服务器不能为正常访问的用户提供服务。利用tcp三次握手协议的缺陷，向目标主机发送大量的伪造源地址的SYN请求，消耗主机的资源，从而不能为正常的用户提供服务。
    </p>
    <h2>攻击原理</h2>
    <ul>
        <li>
            黑客极其向受害主机发送大量伪造源地址的TCP SYN报文，受害主机分配必要的资源，然后向源地址返回SYN-ack包，并等待源端返回ACK包，如图所示，由于源地址是伪造的，所以源daunt永远不会返回ack报文，受害主机继续发送SYN-ack包，并将半连接端口放入端口的挤压队列中，虽然一般的主机都会有超时机制和默认的重传次数，但是由于端口的办连接队列的长度是有限的，如果不断的
            向受害主机发送大量的tcp syn报文，半连接队列很快就会被填满，服务器拒绝新的连接，将导致该端口无法响应其他机器进行的连接请求，最终使受害主机的资源耗尽。
        </li>
    </ul>
    <h2>防御技术</h2>
    <ul>
        <li>
            syn-cookie:当服务器接收到一个syn报文后，不立即分配缓冲区，而是利用连接的信息生成一个cookie，并将这个cookie作为将要返回的SYN-ACK报文的初始序号。当客户端返回一个ACK报文时，根据包头信息计算cookie，与返回的确认序列号的钱24位进行对比，如果相同，则是一个正常连接，然后分配资源，建立连接。
        </li>
        <li>
            该技术的巧妙之处在于避免了在连接信息为完全达到前进行资源分配使SYN flood攻击的资源消耗失效。关键在于cookie的计算，cookie的计算应该做到包含本次连接的状态信息，是攻击者不能伪造cookie。
        </li>
    </ul>
    <h2>缺点</h2>
    <ul>
        <li>
            增加了建立连接的延迟时间。所以不能作为高性能服务器的防御手段
        </li>
        <li>
            当我们避免了SYN flood攻击的同事，也提供了另一种拒绝服务的方式，当攻击者发送大量的ack报文，使服务器忙于计算验证。
        </li>
        <li>
            无法实现超时重传
        </li>
    </ul>
    <h2>地址状态监控的解决方法</h2>
    <p>
        利用监控工具对网络中有关TCP连接的数据包进行监控，并对监听到的数据进行处理，处理的主要依据是请求的源地址。
    </p>
    <ul>
        <li>
            每个源地址都有一个状态与之对应
        </li>
        <li>
            初态：任何源地址刚开始的状态
        </li>
        <li>
            NEW状态：第一次出现或者出现多次也不能断定存在的源地址的状态
        </li>
        <li>
            good状态：断定存在的源地址所处的状态
        </li>
        <li>
            BAD状态：源地址不存在或者不可能达到时所处的状态。
        </li>
        <li>
            实现思路
            <ul>
                <li>
                    对于一个伪造源地址的syn报文，若源地址第一次出现，则源地址的状态为new状态，当监听到服务器的syn+ack报文，表明服务器已经为该源地址的连接请求建立了办连接。此时监控程序待源地址发送一个ack报文完成连接。这样，半连接队列中的半连接数不是很多。计时器开始计时，由于源地址是伪造的，所以是不会收到ack报文，超时后，监控程序发送rst数据包，服务器释放该连接。该源地址状态转为BAD状态，之后对于每一个来自该源头的syn报文，监控程序都主动发送一个rst报文
                </li>
                <li>
                    对于一个合法的SYN报文，若源地址第一次出现，则源地址的状态为new状态，服务器响应请求，发送syn+ack报文，监控程序发送ack报文。服务器可以很好的处理重复到达的ack包。
                </li>
            </ul>
        </li>
    </ul>
</body>
</html>